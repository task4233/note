(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{268:function(t,a,v){"use strict";v.r(a);var e=v(0),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"mc-lang-1-20190908"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mc-lang-1-20190908"}},[t._v("#")]),t._v(" mc-lang 1 20190908")]),t._v(" "),v("ul",[v("li",[t._v("mc-lang全般に含まれているリソースまとめです。")]),t._v(" "),v("li",[t._v("https://github.com/task4233/mc-lang-1")])]),t._v(" "),v("h1",{attrs:{id:"追加した仕様"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#追加した仕様"}},[t._v("#")]),t._v(" 追加した仕様")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("#")]),t._v("でコメントアウト")]),t._v(" "),v("li",[t._v("カッコの実装")]),t._v(" "),v("li",[t._v("二項演算(+,-,*,/)の実yo")])]),t._v(" "),v("h1",{attrs:{id:"lexer-h"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#lexer-h"}},[t._v("#")]),t._v(" lexer.h")]),t._v(" "),v("ul",[v("li",[t._v("字句解析用ヘッダ")]),t._v(" "),v("li",[t._v("このセクションでは、Lexerというテキストから「数字」や「演算子」をまとまり毎に分割するクラスを実装している。")]),t._v(" "),v("li",[t._v("全体的な流れとしては、gettokをParserから呼ぶことにより「次のトークン」を読み、それが数値リテラルだった場合はnumValという変数にセットする。")])]),t._v(" "),v("h2",{attrs:{id:"variables"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#variables"}},[t._v("#")]),t._v(" variables")]),t._v(" "),v("ul",[v("li",[t._v("Token\n"),v("ul",[v("li",[t._v("構造体")])])])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("名称")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("詳細")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("tok_eof")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("EOFトークン(-1)")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("tok_number")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("値を格納")])])])]),t._v(" "),v("h2",{attrs:{id:"functions"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#functions"}},[t._v("#")]),t._v(" functions")]),t._v(" "),v("ul",[v("li",[t._v("getIdentifier()\n"),v("ul",[v("li",[t._v("getter")])])])]),t._v(" "),v("h2",{attrs:{id:"class"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#class"}},[t._v("#")]),t._v(" class")]),t._v(" "),v("h3",{attrs:{id:"lexer"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#lexer"}},[t._v("#")]),t._v(" Lexer")]),t._v(" "),v("h4",{attrs:{id:"public"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#public"}},[t._v("#")]),t._v(" Public")]),t._v(" "),v("ul",[v("li",[t._v("gettok()メソッド\n"),v("ul",[v("li",[t._v("トークンを取得する")]),t._v(" "),v("li",[t._v("#やスペース等をスルーする")])])]),t._v(" "),v("li",[t._v("getNumVal\n"),v("ul",[v("li",[t._v("numValのゲッター")])])]),t._v(" "),v("li",[t._v("setNumVal\n"),v("ul",[v("li",[t._v("numValのセッター")])])]),t._v(" "),v("li",[t._v("initStream\n"),v("ul",[v("li",[t._v("fileNameのファイルをopen")])])])]),t._v(" "),v("h4",{attrs:{id:"private"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#private"}},[t._v("#")]),t._v(" Private")]),t._v(" "),v("ul",[v("li",[t._v("iFile\n"),v("ul",[v("li",[t._v("std::ifstream")])])]),t._v(" "),v("li",[t._v("numVal\n"),v("ul",[v("li",[t._v("保持する数字")])])]),t._v(" "),v("li",[t._v("getNextChar\n"),v("ul",[v("li",[t._v("1文字char型で入力")])])])]),t._v(" "),v("h1",{attrs:{id:"parser-h"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#parser-h"}},[t._v("#")]),t._v(" parser.h")]),t._v(" "),v("ul",[v("li",[t._v("構文解析用ヘッダ")]),t._v(" "),v("li",[t._v("ここのセクションでは、AST（構文解析木）の葉を定義している。")]),t._v(" "),v("li",[t._v("MCコンパイラの根幹であるクラスでLexerとCodeGenで使われている。")]),t._v(" "),v("li",[t._v("Lexerが次のトークンを取ってきて、それが数値リテラルであったらNumberASTに値を格納し、そのポインタを親ノードが保持する。")]),t._v(" "),v("li",[t._v("全てのコードを無事にASTとして表現できたら、後述するcodegenを再帰的に呼び出す事によりオブジェクトファイルを生成する。")])]),t._v(" "),v("h2",{attrs:{id:"variables-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#variables-2"}},[t._v("#")]),t._v(" variables")]),t._v(" "),v("ul",[v("li",[t._v("curTok\n"),v("ul",[v("li",[t._v("読み取ったトークンを保持")])])]),t._v(" "),v("li",[t._v("getNextToken\n"),v("ul",[v("li",[t._v("lexer.hのgettok()")])])]),t._v(" "),v("li",[t._v("BinopPrecedence\n"),v("ul",[v("li",[t._v("mc.cppで定義した結合子の優先権を保持")])])])]),t._v(" "),v("h2",{attrs:{id:"functions-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#functions-2"}},[t._v("#")]),t._v(" functions")]),t._v(" "),v("ul",[v("li",[t._v("GetTokPrecedence()\n"),v("ul",[v("li",[t._v("二項演算子の結合度を取得")]),t._v(" "),v("li",[t._v("もし現在のトークンが二項演算子ならその結合度を返し、そうでないなら-1を返す。")])])]),t._v(" "),v("li",[t._v("LogError(const char *str)\n"),v("ul",[v("li",[t._v("エラーを表示しnullptrを返してくれるエラーハンドリング関数")])])]),t._v(" "),v("li",[t._v("ParseExpressions()\n"),v("ul",[v("li",[t._v("数値リテラル/カッコ->二項演算子の順にパースできるかを確認してパースする")])])]),t._v(" "),v("li",[t._v("ParseNumberExpr()\n"),v("ul",[v("li",[t._v("数値リテラルをパースして内部のexpressionのゆにぽを返す関数")])])]),t._v(" "),v("li",[t._v("ParseParenExpr\n"),v("ul",[v("li",[t._v("カッコ内部のexpressionをパースして内部のexpressionのゆにぽを返す関数")])])]),t._v(" "),v("li",[t._v("ParsePrimary()\n"),v("ul",[v("li",[t._v("NumberASTかカッコをパースするための関数を呼び出す関数")])])]),t._v(" "),v("li",[t._v("ParseBinOpRHS(int CallerPrec, std::unique_ptr<ExprAST> LHS)\n"),v("ul",[v("li",[t._v("二項演算子をパースする関数")]),t._v(" "),v("li",[t._v("LHSが入った状態でよびだされ, LHSとRHSと二項演算子がペアになった状態で返す")])])]),t._v(" "),v("li",[t._v("ParseTopLevelExpr()\n"),v("ul",[v("li",[t._v("パーサーのトップレベル関数")]),t._v(" "),v("li",[t._v("まだ関数定義は実装しないので、今のmc言語では__anon_exprという関数がトップレベルに作られ、その中に全てのASTが入る")])])])]),t._v(" "),v("h2",{attrs:{id:"class-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#class-2"}},[t._v("#")]),t._v(" class")]),t._v(" "),v("h3",{attrs:{id:"exprast"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#exprast"}},[t._v("#")]),t._v(" ExprAST")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("5+2")]),t._v("や"),v("code",[t._v("2*10-2")]),t._v("等のexpressionを表すクラス")])]),t._v(" "),v("h3",{attrs:{id:"numberast"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#numberast"}},[t._v("#")]),t._v(" NumberAST")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("5")]),t._v("や"),v("code",[t._v("2")]),t._v("等の数値リテラルを表すクラス")])]),t._v(" "),v("h4",{attrs:{id:"public-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#public-2"}},[t._v("#")]),t._v(" public")]),t._v(" "),v("ul",[v("li",[t._v("*codegenをオーバーライド")])]),t._v(" "),v("h4",{attrs:{id:"private-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#private-2"}},[t._v("#")]),t._v(" private")]),t._v(" "),v("ul",[v("li",[t._v("Val\n"),v("ul",[v("li",[t._v("数値の値を保持する変数")])])])]),t._v(" "),v("h3",{attrs:{id:"binaryast"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#binaryast"}},[t._v("#")]),t._v(" BinaryAST")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("+")]),t._v("や"),v("code",[t._v("*")]),t._v("等の二項演算子を表すクラス")])]),t._v(" "),v("h4",{attrs:{id:"public-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#public-3"}},[t._v("#")]),t._v(" public")]),t._v(" "),v("ul",[v("li",[t._v("*codegenをオーバーライド")])]),t._v(" "),v("h4",{attrs:{id:"private-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#private-3"}},[t._v("#")]),t._v(" private")]),t._v(" "),v("ul",[v("li",[t._v("Op\n"),v("ul",[v("li",[t._v("char型のオペランド?")])])]),t._v(" "),v("li",[t._v("LHS(Left-hand side)/RHS(Right-hand side)\n"),v("ul",[v("li",[t._v("左辺値/右辺値を指すゆにぽ")])])])]),t._v(" "),v("h3",{attrs:{id:"prototypeast"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#prototypeast"}},[t._v("#")]),t._v(" PrototypeAST")]),t._v(" "),v("ul",[v("li",[t._v("関数シグネチャーで、関数の名前と引数の名前を表すクラス")])]),t._v(" "),v("h4",{attrs:{id:"public-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#public-4"}},[t._v("#")]),t._v(" public")]),t._v(" "),v("ul",[v("li",[t._v("&getName()\n"),v("ul",[v("li",[t._v("保持しているNameのアドレスを返す")])])])]),t._v(" "),v("h4",{attrs:{id:"private-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#private-4"}},[t._v("#")]),t._v(" private")]),t._v(" "),v("ul",[v("li",[t._v("Name\n"),v("ul",[v("li",[t._v("関数名")]),t._v(" "),v("li",[t._v("std::string")])])]),t._v(" "),v("li",[t._v("Args\n"),v("ul",[v("li",[t._v("引数")]),t._v(" "),v("li",[t._v("std::vector<std::string>")])])])]),t._v(" "),v("h3",{attrs:{id:"functionast"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#functionast"}},[t._v("#")]),t._v(" FunctionAST")]),t._v(" "),v("ul",[v("li",[t._v("関数のbody(C++で言うint foo) {...}の中身)を表すクラス")])]),t._v(" "),v("h4",{attrs:{id:"public-5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#public-5"}},[t._v("#")]),t._v(" public")]),t._v(" "),v("ul",[v("li",[t._v("*codegen()")])]),t._v(" "),v("h4",{attrs:{id:"private-5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#private-5"}},[t._v("#")]),t._v(" private")]),t._v(" "),v("ul",[v("li",[t._v("Proto\n"),v("ul",[v("li",[t._v("関数の名前と引数を保持するオブジェクトのゆにぽ")]),t._v(" "),v("li",[t._v("std::unique_ptr<PrototypeAST>")])])]),t._v(" "),v("li",[t._v("Body\n"),v("ul",[v("li",[t._v("関数の中身のexpressionを保持するオブジェクトのゆにぽ")]),t._v(" "),v("li",[t._v("std::unique_ptr<ExprAST>")])])])])])}),[],!1,null,null,null);a.default=r.exports}}]);